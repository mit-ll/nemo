#include <ivl_target.h>

#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <vector>
#include <string>
#include <regex>

#include "nemo.h"

// Finds all security critical signals
void find_critical_sigs(vector<nemo_signal_t>& critical_sigs, ivl_scope_t* root_scopes, unsigned num_root_scopes){
	for (unsigned i = 0; i < num_root_scopes; i++) {
		find_critical_scope_sigs(root_scopes[i], critical_sigs);
	}
}

// Recurse through IVL scope objects (in this case only modules)
// to find all security critical signals
void find_critical_scope_sigs(ivl_scope_t scope, vector<nemo_signal_t>& critical_sigs){
	//@TODO: Look more into dealing with scopes that are not modules
	if (ivl_scope_type(scope) != IVL_SCT_MODULE) {
		fprintf(stderr, "ERROR: cannot parse scope type (%d)\n", ivl_scope_type(scope));
		fprintf(stderr, "File: %s Line: %d\n", ivl_scope_file(scope), ivl_scope_lineno(scope));
		return;
	}

	// Rescurse into any submodules
	for (unsigned i = 0; i < ivl_scope_childs(scope); i++) {
		find_critical_scope_sigs(ivl_scope_child(scope, i), critical_sigs);
	}

	// Enumerate all signals in each scope
	unsigned 	  num_scope_sigs      = ivl_scope_sigs(scope);
	nemo_signal_t current_nemo_signal;

	for (unsigned idx = 0; idx < num_scope_sigs; idx++) {
		current_nemo_signal.ivl_sig = ivl_scope_sig(scope, idx);
		current_nemo_signal.visited = false;
		// Only deal with non IVL generated (local) signals
		if (!is_ivl_generated_signal(current_nemo_signal.ivl_sig)){
			// Check if signal is critical
			if (is_critical_sig(current_nemo_signal.ivl_sig)){
				// Check if signal is arrayed
				if (ivl_signal_packed_dimensions(current_nemo_signal.ivl_sig) > 1) {
					print_full_signal_name(current_nemo_signal.ivl_sig);
					assert(false && "ERROR: Unsupported number of dimensions");
				}
				// Add signal to vector of critical signals
				critical_sigs.push_back(current_nemo_signal);
			}
		}
	}
}

// Returns true if the signal name found in the netlist 
// matches the regex for security critical signals
bool is_critical_sig(ivl_signal_t sig){
	regex  critical_regex(CRITICAL_SIG_REGEX);
	smatch matches;
	string signal_base_name = string(ivl_signal_basename(sig));
	
	regex_search(signal_base_name, matches, critical_regex);
	if (matches.size() > 0 || ENUMERATE_ENTIRE_CIRCUIT){
		return true;
	}
	return false;
}

// Returns true if the signal was generated by the IVL compiler.
// Returns false if the signal is found in the verilog netlist.
// NOTE: signals that are generated by the IVL compiler as outputs
// from constant net objects do not return true.
bool is_ivl_generated_signal(ivl_signal_t sig){
	//@TODO: Deal with larger vectors (more than one nexus)
	//@TODO: Figure out how more than one nexus works...
	const ivl_nexus_t nexus = ivl_signal_nex(sig, 0);
	const int         count = ivl_signal_array_count(sig);
	assert(count >= 0 && "ERROR: invalid nexus count\n");
	if (count > 1){
		fprintf(stderr, "ERROR: cannot process arrayed signal: %s\n", ivl_signal_basename(sig));
		fprintf(stderr, "File: %s Line: %d\n", ivl_signal_file(sig), ivl_signal_lineno(sig));
		exit(-1);
	}
	assert(nexus && "ERROR: invalid nexus for signal\n");

	// If option to include local signals is true, return false
	if (INCLUDE_LOCAL_SIGNALS){
		return false;
	}

	// Check if the signal was generated by IVL compiler front-end
	if (!ivl_signal_local(sig)){
		// signal was not generated by IVL compiler, return false
		return false;
	} else {
		// signal was generated by IVL compiler, check if it is 
		// the output of a constant net object
		if (is_const_local_sig(sig)){
			// signal is the output of a constant net object
			return false;
		} else{
			// signal is NOT the output of a constant net object
			return true;
		}
	}
}

// Returns true if the signal was generated by the IVL
// compiler as an output from a constant net object
bool is_const_local_sig(ivl_signal_t sig){
	ivl_nexus_t 	nexus     = ivl_signal_nex(sig, 0);
	ivl_nexus_ptr_t nexus_ptr = NULL;
	ivl_net_const_t con       = NULL;

	// Check if local signal is connected to a constant
	for(unsigned i = 0; i < ivl_nexus_ptrs(nexus); i++){
		nexus_ptr = ivl_nexus_ptr(nexus, i);
		if ((con = ivl_nexus_ptr_con(nexus_ptr))){
			return true;
		}
	}

	return false;
}

// void color_signal_visited(ivl_signal_t sig){
// 	return;
// }

// void clean_up_signal_attrs(vector<ivl_signal_t>& critical_sigs){
// 	return;
// }

// Prints the full signal name (<module name>.<signal name>) to stdin
void print_full_signal_name(ivl_signal_t sig){
	string tmp_scopename = string(ivl_scope_name(ivl_signal_scope(sig))); 
	string tmp_basename  = string(ivl_signal_basename(sig));
	string tmp_fullname  = string(tmp_scopename + string(".") + tmp_basename);
	printf("%-15s (%d)\n", tmp_fullname.c_str(), ivl_signal_width(sig));
}

// Prints all signal attributes to stdin
void print_signal_attrs(ivl_signal_t sig){
	for (unsigned idx = 0;  idx < ivl_signal_attr_cnt(sig);  idx += 1) {
		ivl_attribute_t atr = ivl_signal_attr_val(sig, idx);

		switch (atr->type) {
			case IVL_ATT_STR:
				printf("    %s = %s\n", atr->key, atr->val.str);
				break;
			case IVL_ATT_NUM:
				printf("    %s = %ld\n", atr->key, atr->val.num);
				break;
			case IVL_ATT_VOID:
				printf("    %s\n", atr->key);
				break;
			default:
				break;
		}
	}
}

// Prints all signal names and attributes to stdin
void print_signals(vector<nemo_signal_t>& sigs){
	printf("\nNumber of Critical Signals Found: %lu\n", sigs.size());
	for (unsigned i = 0; i < sigs.size(); i++){
		print_full_signal_name(sigs[i].ivl_sig);
		print_signal_attrs(sigs[i].ivl_sig);
	}
	printf("\n");
}

// *** "Main"/Entry Point *** of iverilog target
int target_design(ivl_design_t des) {
	ivl_scope_t* 		  roots = 0;     // root scopes of the design
	unsigned 		      num_roots;     // number of root scopes of the design
	vector<nemo_signal_t> critical_sigs; // all critical signals in the design
	Dot_File 			  df;  			// output graph dot file

	// Variables to calculate runtime of this target module
	double  duration;	
	clock_t start = std::clock(); // Start timer

	// Get root scopes of design
	ivl_design_roots(des, &roots, &num_roots);
	printf("\nNumber of Root Scopes: %d\n", num_roots);
	
	// Find all critical signals in the design
	find_critical_sigs(critical_sigs, roots, num_roots);
	print_signals(critical_sigs);

	// Write all nodes to the graph dot file
	df = Dot_File(ivl_design_flag(des, "-o"));
	df.init_graph();
	for (vector<nemo_signal_t>::iterator it = critical_sigs.begin(); it != critical_sigs.end(); ++it){
		df.add_node((*it).ivl_sig);
	}

	// Determine the dependencies for critical connections
	for (vector<nemo_signal_t>::iterator it = critical_sigs.begin(); it != critical_sigs.end(); ++it){
		//@TODO: Support more than 1 dimension vector
		//       Though it looks like it should be ok for OR1200
		assert(ivl_signal_packed_dimensions((*it).ivl_sig) <= 1 && "ERROR: cannot support multi-dimensional vectors.\n");
		propagate_sig((*it).ivl_sig, df);
	}

	// Close graph dot file
	df.save_graph();

	// Stop timer
	duration = (std::clock() - start) / (double) CLOCKS_PER_SEC;
	printf("Execution Time: %f (s)\n\n", duration);

	return 0;
}
