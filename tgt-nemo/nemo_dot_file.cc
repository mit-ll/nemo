#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <string>

#include <ivl_target.h>
#include "nemo.h"
#include "nemo_dot_file.h"

using namespace std;

Dot_File::Dot_File(): path(NULL), file_ptr(NULL){}

Dot_File::Dot_File(const char* p): file_ptr(NULL){
	set_path(p);
}

void Dot_File::set_path(const char* p){
	path = p;
}

const char* Dot_File::get_path(){
	return path;
}

FILE* Dot_File::get_file_ptr(){
	return file_ptr;
}

void Dot_File::open_file(){
	file_ptr = fopen(path, "w");
	if (!file_ptr) {
		printf("ERROR: Could not open file %s\n", path ? path : "stdout");
		exit(-4);
	}
}

void Dot_File::close_file(){
	fclose(file_ptr);
	file_ptr = NULL;
}

unsigned long Dot_File::get_msb(ivl_signal_t sig){
	unsigned num_dimens = ivl_signal_packed_dimensions(sig);

	if (num_dimens == 0) {
		return 0;
	} else{
		return ivl_signal_packed_msb(sig, 0);
	}
}

unsigned long Dot_File::get_lsb(ivl_signal_t sig){
	unsigned num_dimens = ivl_signal_packed_dimensions(sig);
	
	if (num_dimens == 0) {
		return 0;
	} else{
		return ivl_signal_packed_lsb(sig, 0);
	}
}

void Dot_File::init_graph(){
	open_file();
	fprintf(file_ptr, "digraph G {\n");
}

void Dot_File::add_node(ivl_signal_t sig){
	string scopename = string(ivl_scope_name(ivl_signal_scope(sig))); 
	string basename  = string(ivl_signal_basename(sig));
	string fullname  = string(scopename + string(".") + basename);

	// Make local signals (placeholder signals generated by the IVL compiler)
	// just points instead of full nodes
    if (ivl_signal_local(sig)) {
		fprintf(file_ptr, "\t\"%s\" [shape=%s, label=\"%s[%lu:%lu]\"]; /* IVL */\n", 
			fullname.c_str(), INCLUDE_LOCAL_SIGNALS ? "ellipse" : "point", fullname.c_str(), get_msb(sig), get_lsb(sig));
    } else if (IVL_SIP_INOUT == ivl_signal_port(sig)) {
		fprintf(file_ptr, "\t\"%s\" [shape=diamond, label=\"%s[%lu:%lu]\"]; /* InOut */\n", 
			fullname.c_str(), fullname.c_str(), get_msb(sig), get_lsb(sig));
	}  else if (IVL_SIP_OUTPUT == ivl_signal_port(sig)) {
		fprintf(file_ptr, "\t\"%s\" [shape=trapezium, label=\"%s[%lu:%lu]\"]; /* Output */\n", 
			fullname.c_str(), fullname.c_str(), get_msb(sig), get_lsb(sig));
    } else if (IVL_SIP_INPUT == ivl_signal_port(sig)) {
		fprintf(file_ptr, "\t\"%s\" [shape=invtrapezium, label=\"%s[%lu:%lu]\"]; /* Input */\n", 
			fullname.c_str(), fullname.c_str(), get_msb(sig), get_lsb(sig));
    } else {
		fprintf(file_ptr, "\t\"%s\" [shape=ellipse, label=\"%s[%lu:%lu]\"];\n", 
			fullname.c_str(), fullname.c_str(), get_msb(sig), get_lsb(sig));
    }
}

void Dot_File::add_const_node(ivl_net_const_t con){
	string scopename = string(ivl_scope_name(ivl_const_scope(con))); 
	string basename  = string(ivl_const_bits(con), (size_t)ivl_const_width(con));
	reverse(basename.begin(), basename.end());
	string fullname  = string(scopename + string(".const_") + basename);

	fprintf(file_ptr, "\t\"%s\" [shape=rectangle, label=\"%s[%lu:%lu]\"]; /* Constant */\n", 
		fullname.c_str(), fullname.c_str(), (unsigned long)(ivl_const_width(con) - 1), (unsigned long)0);
}

void Dot_File::add_connection(ivl_signal_t aff_sig, ivl_signal_t sig){
	ivl_net_const_t con;

	// First Signal Name
	string scopename_1 = string(ivl_scope_name(ivl_signal_scope(aff_sig))); 
	string basename_1  = string(ivl_signal_basename(aff_sig));
	string fullname_1  = string(scopename_1 + string(".") + basename_1);
	
	// Second Signal Name
	string scopename_2 = string(ivl_scope_name(ivl_signal_scope(sig))); 
	string basename_2  = string(ivl_signal_basename(sig));
	string fullname_2  = string(scopename_2 + string(".") + basename_2);

	if ((con = is_const_local_sig(sig))){
		// signal was generated by the IVL compiler as
		// the output of a constant object, add constant
		// connection only
		add_const_connection(aff_sig, con);
	} else {
		fprintf(file_ptr, "\t\"%s\" -> \"%s\"[label=\"[%lu:%lu]->[%lu:%lu]\"];\n", 
			fullname_2.c_str(), fullname_1.c_str(), get_msb(sig), get_lsb(sig), get_msb(aff_sig), get_lsb(aff_sig));	
	}
}

void Dot_File::add_connection(ivl_signal_t aff_sig, ivl_signal_t sig, unsigned long sig_msb, unsigned long sig_lsb){
	ivl_net_const_t con;

	// First Signal Name
	string scopename_1 = string(ivl_scope_name(ivl_signal_scope(aff_sig))); 
	string basename_1  = string(ivl_signal_basename(aff_sig));
	string fullname_1  = string(scopename_1 + string(".") + basename_1);
	
	// Second Signal Name
	string scopename_2 = string(ivl_scope_name(ivl_signal_scope(sig))); 
	string basename_2  = string(ivl_signal_basename(sig));
	string fullname_2  = string(scopename_2 + string(".") + basename_2);

	if ((con = is_const_local_sig(sig))){
		// signal was generated by the IVL compiler as
		// the output of a constant object, add constant
		// connection only
		assert(false && "ERROR: cannot connect a spliced constant.");
	} else {
		fprintf(file_ptr, "\t\"%s\" -> \"%s\"[label=\"[%lu:%lu]->[%lu:%lu]\"];\n", 
		fullname_2.c_str(), fullname_1.c_str(), sig_msb, sig_lsb, get_msb(aff_sig), get_lsb(aff_sig));	
	}	
}

void Dot_File::add_connection(ivl_signal_t aff_sig, unsigned long aff_sig_msb, unsigned long aff_sig_lsb, ivl_signal_t sig){
	ivl_net_const_t con;

	// First Signal Name
	string scopename_1 = string(ivl_scope_name(ivl_signal_scope(aff_sig))); 
	string basename_1  = string(ivl_signal_basename(aff_sig));
	string fullname_1  = string(scopename_1 + string(".") + basename_1);
	
	// Second Signal Name
	string scopename_2 = string(ivl_scope_name(ivl_signal_scope(sig))); 
	string basename_2  = string(ivl_signal_basename(sig));
	string fullname_2  = string(scopename_2 + string(".") + basename_2);

	if ((con = is_const_local_sig(sig))){
		// signal was generated by the IVL compiler as
		// the output of a constant object, add constant
		// connection only
		add_const_spliced_connection(aff_sig, aff_sig_msb, aff_sig_lsb, con);
	} else {
		fprintf(file_ptr, "\t\"%s\" -> \"%s\"[label=\"[%lu:%lu]->[%lu:%lu]\"];\n", 
		fullname_2.c_str(), fullname_1.c_str(), get_msb(sig), get_lsb(sig), aff_sig_msb, aff_sig_lsb);	
	}
}

void Dot_File::add_const_connection(ivl_signal_t aff_sig, ivl_net_const_t con){
	// First Signal Name
	string scopename_1 = string(ivl_scope_name(ivl_signal_scope(aff_sig))); 
	string basename_1  = string(ivl_signal_basename(aff_sig));
	string fullname_1  = string(scopename_1 + string(".") + basename_1);
	
	// Second Signal Name
	string scopename_2 = string(ivl_scope_name(ivl_const_scope(con))); 
	string basename_2  = string(ivl_const_bits(con), (size_t)ivl_const_width(con));
	reverse(basename_2.begin(), basename_2.end());
	string fullname_2  = string(scopename_2 + string(".const_") + basename_2);

	fprintf(file_ptr, "\t\"%s\" -> \"%s\"[label=\"[%lu:%lu]->[%lu:%lu]\"];\n", 
		fullname_2.c_str(), fullname_1.c_str(), (unsigned long)(ivl_const_width(con) - 1), (unsigned long)0, get_msb(aff_sig), get_lsb(aff_sig));
}

void Dot_File::add_const_spliced_connection(ivl_signal_t aff_sig, unsigned long aff_sig_msb, unsigned long aff_sig_lsb, ivl_net_const_t con){
	// First Signal Name
	string scopename_1 = string(ivl_scope_name(ivl_signal_scope(aff_sig))); 
	string basename_1  = string(ivl_signal_basename(aff_sig));
	string fullname_1  = string(scopename_1 + string(".") + basename_1);
	
	// Second Signal Name
	string scopename_2 = string(ivl_scope_name(ivl_const_scope(con))); 
	string basename_2  = string(ivl_const_bits(con), (size_t)ivl_const_width(con));
	reverse(basename_2.begin(), basename_2.end());
	string fullname_2  = string(scopename_2 + string(".const_") + basename_2);

	fprintf(file_ptr, "\t\"%s\" -> \"%s\"[label=\"[%lu:%lu]->[%lu:%lu]\"];\n", 
		fullname_2.c_str(), fullname_1.c_str(), (unsigned long)(ivl_const_width(con) - 1), (unsigned long)0, aff_sig_msb, aff_sig_lsb);
}

void Dot_File::save_graph(){
	fprintf(file_ptr, "}\n");
	close_file();
}
